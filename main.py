from __future__ import print_function
import pickle
import time 
import random
import os.path
from email.mime.text import MIMEText
import base64
import re

from googleapiclient.discovery import build
from googleapiclient import errors
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

from parse import parseEmail
from gamestate import addPlayersIntoList, recieveEmail, Player

# If modifying these scopes, delete the file token.pickle.
SCOPES = ['https://mail.google.com/']
service = None
maxIterations = 4
# players = {}

threads = []

#starting emails
#player 1 email automadlibs@gmail.com 
#starting sentences
# #max iterations

# def create_and_send_multiple_emails(service, message, emails):
#   for email in emails: 
#     create_and_send_email(service, message,email)

def initBot():
  iterations = 0
  email = "automadlibs@gmail.com"
  initalEmail = "cbroms@andrew.cmu.edu"
  message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit."
  threadId = create_and_send_email(service, generateMessage(message, email), "It's your turn to play!", initalEmail )
  threads.append({"message": message, "email": email, "sentTo": initalEmail})

def generateMessage(prevSentence, prevEmail):
  return "Howdy!\n" + \
  "You've been nominated by " + prevEmail + " to add to a story being generated by many players over email. " + \
  "Please reply to this email with your next sentence and a new player's email.\n\n"+ \
  "The previous sentence in the story: " + prevSentence + "\n\n" + \
  "Your contribution will be sentence " + str(len(threads) + 1) + " of " + str(maxIterations) + ".\n" + \
  "Thanks for participating!\n-Ryan Libs\n\n" + \
  "PS: This email is not a scam; the purpose of this email is to collect the provided answers to use in an art project. You were invited to participate through the nomination of the individual listed above. Your participation in this project is completely voluntary and to help protect your privacy, the project will not collect or contain any personally identifying information. By replying to this email with the necessary answers, you are agreeing to participate in the project. To opt out, please disregard this email." 



def create_message(sender, to, subject, message_text):

  message = MIMEText(message_text)
  message['to'] = to
  message['from'] = sender
  message['subject'] = subject
  return {"raw": str( base64.b64encode(message.as_bytes()), "utf-8")}

def create_draft(service, user_id, message_body):
  try:
    message = {'message': message_body}
    draft = service.users().drafts().create(userId=user_id, body=message).execute()
    return draft
  except errors.HttpError as e:
    print( e )
    return None

# create an email and send it 
def create_and_send_email(service, message, subject, recipient):
    email = create_message("automadlibs@gmail.com", recipient, subject, message)
    draft = create_draft(service, "me", email)
    res = service.users().drafts().send(userId="me", body={"id": draft["id"]}).execute()
    return res["threadId"]



def sync_emails(service, history=None):

  if history is not None:
    print("checking for new messages... ", end="")
    res = service.users().history().list(userId="me", startHistoryId=history).execute()
    if "history" in res and "messagesAdded" in res["history"][0]:
      for message in res["history"][0]["messagesAdded"]:
        print("\nnew message found, threadId: {}".format(message["message"]["threadId"]))
        # get the message content 
        try:
          res = service.users().messages().get(userId="me", id=message["message"]["id"], format="full").execute()
          content = ""
          if "parts" in res["payload"]:
            decodedBytes = base64.urlsafe_b64decode(res["payload"]["parts"][0]["body"]["data"])
            content = str(decodedBytes, "utf-8")
          else:
            decodedBytes = base64.urlsafe_b64decode(res["payload"]["body"]["data"])
            content = str(decodedBytes, "utf-8")
          # parse the message, extracting the new sentence, in addition to new emails 
          parsed = parseEmail(content)
          print(parsed.user_emails, parsed.user_sentence)
         
          # check if the emailer included a new email, and if not add a default one
          fromEmail = ""
          toEmail = ""
          if len(parsed.user_emails) > 0:
            fromEmail = threads[len(threads) - 1]["sentTo"]
            toEmail = parsed.user_emails[0]
          else:
            fromEmail = "automadlibs@gmail.com"
            toEmail = random.choice(threads)["email"]

          if len(threads) >= maxIterations:
            # compile the story and send to everyone 
            story = ""
            for thread in threads:
              story += " " + thread["message"]
            story += " " + parsed.user_sentence

            # send out the story 
            for thread in threads:
              create_and_send_email(service, story, "The final story", thread["email"])

          else:
            # send the previous sentence to the next person in the list 
            msg = generateMessage(parsed.user_sentence, fromEmail)
            threadId = create_and_send_email(service, msg, "It's your turn to play", toEmail)
            # update the game state with the response and new email
            threads.append({"message": parsed.user_sentence, "email": fromEmail,  "sentTo": toEmail})
        except:
          print("something went wrong")
          pass
        
    else:
      print("no new messages found")
    return res["historyId"]
  else:
    print("syncing inbox... ", end="")
    # get a list of the most recent messages in the inbox 
    res = service.users().messages().list(userId="me").execute()
    # get the most recent message's id 
    most_recent = res["messages"][0]["id"]
    # get the history timestamp of the most recent message 
    res = service.users().messages().get(userId="me", id=most_recent).execute()
    print("sync done")
    return res["historyId"]

def main():
    creds = None
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)
    global service 

    service = build('gmail', 'v1', credentials=creds)
    # now we can use the service to send, create, search through gmail 

    initBot()

    history = sync_emails(service)

    # check for new mail every 15 seconds 
    while True:
      # get any new replies and deal with them (parse, send to invited friends, etc)
      history = sync_emails(service, history)
      time.sleep(5)


    
if __name__ == '__main__':
    main()
